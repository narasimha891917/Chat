<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ultimate Chat App</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f0f0f0; }
    #loginScreen, #chatScreen { display: none; padding: 20px; }
    #loginScreen { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
    #chatScreen { height: 100vh; display: flex; flex-direction: column; }
    input, button { padding: 10px; margin: 5px; }
    #messages { flex-grow: 1; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: white; }
    .message { padding: 5px; margin: 3px; border-bottom: 1px solid #eee; }
    .system { color: gray; font-style: italic; }
    .typing { color: blue; font-style: italic; }
    .online { color: green; }
    .offline { color: red; }
    #localVideo, #remoteVideo { width: 100px; height: 80px; background: black; }
    #videoContainer { display: flex; gap: 10px; margin-top: 10px; }
  </style>
</head>
<body>

<div id="loginScreen">
  <h2>Enter your username</h2>
  <input type="text" id="usernameInput" placeholder="Your name"/>
  <button onclick="login()">Enter</button>
</div>

<div id="chatScreen">
  <div>
    <strong>Logged in as:</strong> <span id="myName"></span>
    <span style="float:right">
      Chat with: <input type="text" id="chatWith" placeholder="Username" />
    </span>
  </div>

  <div id="status">
    <span id="otherUserStatus" class="offline">Offline</span>
    <span id="typingStatus" class="typing"></span>
  </div>

  <div id="messages"></div>

  <input type="text" id="messageInput" placeholder="Type a message..." oninput="sendTyping()" />
  <button onclick="sendMessage()">Send</button>
  <button onclick="startAudioCall()">Audio Call</button>
  <button onclick="startVideoCall()">Video Call</button>

  <div id="videoContainer">
    <video id="localVideo" autoplay muted></video>
    <video id="remoteVideo" autoplay></video>
  </div>
</div>

<!-- Firebase & WebRTC JS -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyBlqw_OlPWzL1Gvv4n0068BVlnstoFqdsw",
  authDomain: "student-attendance-b1e33.firebaseapp.com",
  databaseURL: "https://student-attendance-b1e33-default-rtdb.firebaseio.com",
  projectId: "student-attendance-b1e33",
  storageBucket: "student-attendance-b1e33.firebasestorage.app",
  messagingSenderId: "601501410721",
  appId: "1:601501410721:web:809bd651e283675b8c57e0",
  measurementId: "G-2R0Q549S7B"
};
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  let myName = "", chatWith = "", typingTimeout;
  const messagesEl = document.getElementById("messages");

  function login() {
    myName = document.getElementById("usernameInput").value.trim();
    if (!myName) return alert("Enter a valid username");
    document.getElementById("loginScreen").style.display = "none";
    document.getElementById("chatScreen").style.display = "block";
    document.getElementById("myName").textContent = myName;

    db.ref("presence/" + myName).set(true);
    db.ref("presence/" + myName).onDisconnect().remove();
    listenForTyping();
    listenForMessages();
    monitorPresence();
  }

  function sendMessage() {
    const input = document.getElementById("messageInput");
    if (!input.value.trim()) return;
    const msg = {
      from: myName,
      to: chatWith,
      text: input.value,
      timestamp: Date.now()
    };
    db.ref("messages").push(msg);
    input.value = "";
  }

  function sendTyping() {
    db.ref("typing/" + chatWith).set(myName);
    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => {
      db.ref("typing/" + chatWith).set("");
    }, 3000);
  }

  function listenForTyping() {
    db.ref("typing/" + myName).on("value", snap => {
      document.getElementById("typingStatus").textContent = snap.val() ? snap.val() + " is typing..." : "";
    });
  }

  function listenForMessages() {
    db.ref("messages").on("child_added", snap => {
      const msg = snap.val();
      if ((msg.from === myName && msg.to === chatWith) || (msg.from === chatWith && msg.to === myName)) {
        const div = document.createElement("div");
        div.className = "message";
        div.textContent = `${msg.from}: ${msg.text}`;
        messagesEl.appendChild(div);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        if (msg.to === myName) {
          setTimeout(() => snap.ref.remove(), 60000);
        }
      }
    });
  }

  function monitorPresence() {
    setInterval(() => {
      chatWith = document.getElementById("chatWith").value.trim();
      if (chatWith) {
        db.ref("presence/" + chatWith).once("value").then(snap => {
          document.getElementById("otherUserStatus").textContent = snap.exists() ? "Online" : "Offline";
          document.getElementById("otherUserStatus").className = snap.exists() ? "online" : "offline";
        });
      }
    }, 3000);
  }

  // WebRTC Call Setup
  let localStream, peerConnection;
  const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  async function startCall(isVideo) {
    chatWith = document.getElementById("chatWith").value.trim();
    localStream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
    document.getElementById("localVideo").srcObject = localStream;
    peerConnection = new RTCPeerConnection(config);

    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    peerConnection.ontrack = event => {
      document.getElementById("remoteVideo").srcObject = event.streams[0];
    };

    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        db.ref(`calls/${chatWith}/candidates`).push({ from: myName, candidate: event.candidate });
      }
    };

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    db.ref(`calls/${chatWith}`).set({ from: myName, offer });
  }

  db.ref("calls").on("child_added", async snap => {
    const call = snap.val();
    if (call.to === myName && call.offer) {
      if (!confirm(`${call.from} is calling you. Accept?`)) return;
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      document.getElementById("localVideo").srcObject = localStream;
      peerConnection = new RTCPeerConnection(config);

      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
      peerConnection.ontrack = event => {
        document.getElementById("remoteVideo").srcObject = event.streams[0];
      };
      peerConnection.onicecandidate = e => {
        if (e.candidate) {
          db.ref(`calls/${call.from}/candidates`).push({ from: myName, candidate: e.candidate });
        }
      };

      await peerConnection.setRemoteDescription(new RTCSessionDescription(call.offer));
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      db.ref(`calls/${call.from}/answer`).set(answer);
    }
  });

  function startVideoCall() {
    startCall(true);
  }

  function startAudioCall() {
    startCall(false);
  }

  db.ref("calls").on("child_changed", async snap => {
    const call = snap.val();
    if (call.answer && peerConnection) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(call.answer));
    }
  });

  db.ref("calls").on("child_added", snap => {
    const id = snap.key;
    snap.ref.child("candidates").on("child_added", snap => {
      const data = snap.val();
      if (data.from !== myName && peerConnection) {
        peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    });
  });
</script>
</body>
</html>
